import numpy as np
import AsciiIO
import SettingsIO
"""
alpha,m,Sdbar,dl,dt,n0,T0,Srmax
"""


def read_alpha_m(path):
    """
    :param path: the path of the .bp file in the input folder
    :return: basin_id: e.g. np.array([0,1]),
             alpha:  e.g. np.array([-3,-3]),
             m:  e.g. np.array([0.1,0.1])
    """
    with open(path) as f:
        text = f.readlines()
        text = [i[:-1] for i in text[1:]]
        params = np.genfromtxt(text)
        basin_id = params[:,0]
        alpha = params[:,1]
        m = params[:,2]
    return basin_id,alpha,m


def write_alpha_m(basin_id,alpha,m,path):
    """
    :param basin_id: e.g. np.array([0,1])
    :param alpha:  e.g. np.array([-3,-3])
    :param m:  e.g. np.array([0.1,0.1])
    :param path: the .bp file in the input folder
    :return: None
    """
    #print("a m", alpha,m)
    header = "Basin_ID\talpha()\tm()\n"
    params = np.array([basin_id,alpha,m]).transpose()
    params = params.tolist()
    for i in params:
        i[0] = int(i[0])
    text = ["{}\t{}\t{}\n".format(i[0],i[1],i[2]) for i in params]
    with open(path,"w") as f:
        f.write(header)
        f.writelines(text)


def read_sdbar(path):
    with open(path) as f:
        text = f.readlines()
        text = [i[:-1] for i in text[1:]]
        params = np.genfromtxt(text)
        basin_id = params[:,0]
        sdbar = params[:,1]

    return basin_id,sdbar


def write_sdbar(basin_id, sdbar, path):
    """
    :param basin_id: e.g. np.array([0,1])
    :param sdbar: e.g. np.array([0.03,0.03])
    :param path:  the .sdbar file in the input folder
    :return: None
    """
    #print("sdbar", sdbar)
    header = "Basin_ID\tsdbar(0)(m)\n"
    params = np.array([basin_id,sdbar]).transpose()
    params = params.tolist()
    for i in params:
        i[0] = int(i[0])
    text = ["{}\t{}\n".format(i[0],i[1]) for i in params]
    with open(path,"w") as f:
        f.write(header)
        f.writelines(text)


def read_dl_dt(path):
    with open(path) as f:
        text = f.readlines()
    line_n = 0
    for i in range(len(text)):
        if "max_div" in text[i]:
            line_n = i
    info_line = text[line_n]
    try:
        params = info_line.split(" ")
        params = [i for i in params if i != ""]
        dl = int(params[1])
        dt = int(params[2])
    except:
        params = info_line.split("\t")
        params = [i for i in params if i != ""]
        dl = int(params[1])
        dt = int(params[2])

    return dl, dt


def write_dl_dt(dl, dt, path):
    with open(path, "r") as f:
        text = f.readlines()
        line_n = 0
        for i in range(len(text)):
            if "max_div" in text[i]:
                line_n = i
    with open(path, "w") as f:
        info_line = "\tmax_div\t{}\t\t{}\n".format(dl, dt)
        text[line_n] = info_line
        f.writelines(text)


def pop_nan(data, no_data_value):
    # nan_index = np.argwhere(data == no_data_value)
    index = np.argwhere(data != no_data_value)
    values = data[data != no_data_value]

    return index, values


def update_param(data, new_data, index):
    """
    This is a function for parameter updating when executing the optimization algorithm.
    Update the not-nan value for the grid parameters.
    :param data: original parameter matrix
    :param new_data: the 1-dimensional parameter vector (generated by the optimization algorithms) without no data value
    :param index: the index of not nan values (the return value of pop_nan method)
    :return:  updated param matrix with no data value
    """
    index_x = index[:, 0].flatten()
    index_y = index[:, 1].flatten()
    data[index_x, index_y] = new_data
    return data


def update_sub_basin_param(data, new_data, f_sub_basin):
    """
    Update the paratemers in a sub-basin scale
    :param data:
    :param new_data:
    :param f_sub_basin:
    :return: updated param matrix with no data value
    """
    #print("n0",new_data)
    sub_basin_id, sub_basin_index = read_sub_basin(f_sub_basin)
    for i in range(len(sub_basin_id)):
        index_x = sub_basin_index[i][:, 0].flatten()
        index_y = sub_basin_index[i][:, 1].flatten()
        data[index_x, index_y] = new_data[i]

    return data


def update_class_param(data, new_data, f):
    """
    Update the t0 or srm in a class scale
    :param data:
    :param new_data:
    :param f: soil type file or landuse file
    :return: updated param matrix with no data value
    """
    #print("t0,srm", new_data)
    classes, indexes = read_lu_soil(f)
    for i in range(len(classes)):
        index_x = indexes[i][:, 0].flatten()
        index_y = indexes[i][:, 1].flatten()
        data[index_x, index_y] = new_data[i]
    return data

def updatate_particle_param(data,new_t0,f_soil,f_soil_des):
    classes, indexes = read_lu_soil(f_soil)
    soil_des = read_soil_description(f_soil_des)
    class_t0 = []
    for i in classes:
        soil_fraction = soil_des[i]
        i_t0 = new_t0[0] * soil_fraction[0] / 100 + new_t0[1] * soil_fraction[1] / 100 + new_t0[2] * soil_fraction[2] / 100
        class_t0.append(i_t0)
    for i in range(len(classes)):
        index_x = indexes[i][:, 0].flatten()
        index_y = indexes[i][:, 1].flatten()
        data[index_x, index_y] = class_t0[i]
    return data

def read_lu_soil(path):
    headers, data, no_data_value = AsciiIO.read(path)
    classes = np.unique(data).astype("int32")
    indexes = []
    for i in classes:
        index = np.argwhere(data == i)
        indexes.append(index)
    return classes, indexes


def form_param_sequence(f_alpha_m, f_Sdbar, f_dl_dt, f_n0, f_T0, f_Srmax, f_soil, f_lu):
    # alpha,m,Sdbar,dl,dt,n0,T0,Srmax
    # alpha,m
    n0_method, t0_method, srm_method = SettingsIO.read_opt_settings()[-3:]
    basin_id, alpha, m = read_alpha_m(f_alpha_m)
    l_alpha = len(alpha)
    l_m = len(m)
    # n0
    if n0_method == "Grid":
        n0_headers, n0_ini, n0_no_data_value = AsciiIO.read(f_n0)
        n0_index, n0 = pop_nan(n0_ini,n0_no_data_value)
        l_n0 = len(n0)
    else:
        n0_headers, n0_ini, n0_no_data_value = AsciiIO.read(f_n0)
        n0 = np.random.randn(len(basin_id))
        n0 = n0.tolist()
        n0_index, _ = pop_nan(n0_ini, n0_no_data_value)
        l_n0 = len(basin_id)
    # sdbar
    basin_id, sdbar = read_sdbar(f_Sdbar)
    l_sdbar = len(sdbar)
    # t0
    if t0_method == "Grid":
        t0_headers, t0_ini, t0_no_data_value = AsciiIO.read(f_T0)
        t0_index, t0 = pop_nan(t0_ini, t0_no_data_value)
        l_t0 = len(t0)
    elif t0_method == "Particle":
        t0_headers, t0_ini, t0_no_data_value = AsciiIO.read(f_T0)
        l_t0 = 3
        t0 = np.random.randn(3)
        t0_index, _ = pop_nan(t0_ini, t0_no_data_value)
    else:
        t0_headers, t0_ini, t0_no_data_value = AsciiIO.read(f_T0)
        soil_types, _ = read_lu_soil(f_soil)
        l_t0 = len(soil_types)
        t0_index, _ = pop_nan(t0_ini, t0_no_data_value)
        t0 = np.random.randn(len(soil_types))
        t0 = t0.tolist()
    # srm
    if srm_method == "Grid":
        srm_headers, srm_ini, srm_no_data_value = AsciiIO.read(f_Srmax)
        srm_index, srm = pop_nan(srm_ini, srm_no_data_value)
        l_srm = len(srm)
    else:
        srm_headers, srm_ini, srm_no_data_value = AsciiIO.read(f_Srmax)
        classes, _ = read_lu_soil(f_lu)
        l_srm = len(classes)
        srm_index, _ = pop_nan(srm_ini, srm_no_data_value)
        srm = np.random.randn(len(classes))
        srm = srm.tolist()
    # dl, dt
    dl, dt = read_dl_dt(f_dl_dt)
    param_sequence = []
    param_sequence.extend(alpha)
    param_sequence.extend(m)
    param_sequence.extend(sdbar.tolist())
    param_sequence.extend([dl, dt])
    param_sequence.extend(n0)
    param_sequence.extend(t0)
    param_sequence.extend(srm)
    lengths = (l_alpha, l_m, l_sdbar, 2, l_n0, l_t0, l_srm)
    fun = lambda x: sum(x)
    param_end_pos = [fun(lengths[:i+1]) for i in range(len(lengths))]
    return param_sequence,param_end_pos,n0_index,t0_index,srm_index,basin_id


def write_params(param_sequence, param_end_pos,
                 n0_index, t0_index, srm_index,
                 f_alpha_m, f_Sdbar, f_dl_dt, f_n0, f_T0, f_Srmax,
                 basin_id, f_sub_basin, f_soil, f_lu,f_soil_des):
    #print(param_end_pos)
    n0_method, t0_method, srm_method = SettingsIO.read_opt_settings()[-3:]
    alpha = param_sequence[:param_end_pos[0]]
    m = param_sequence[param_end_pos[0]:param_end_pos[1]]
    sdbar = param_sequence[param_end_pos[1]:param_end_pos[2]]
    dl,dt = param_sequence[param_end_pos[2]:param_end_pos[3]]
    dl,dt = int(dl), int(dt)
    n0_headers, n0, _ = AsciiIO.read(f_n0)
    t0_headers, t0, _ = AsciiIO.read(f_T0)
    srm_headers, srm, _ = AsciiIO.read(f_Srmax)
    new_n0 = param_sequence[param_end_pos[3]:param_end_pos[4]]
    new_t0 = param_sequence[param_end_pos[4]:param_end_pos[5]]
    new_srm = param_sequence[param_end_pos[5]:param_end_pos[6]]
    if n0_method == "Grid":
        n0 = update_param(n0, new_n0, n0_index)
    else:
        n0 = update_sub_basin_param(n0, new_n0, f_sub_basin)
    if t0_method == "Grid":
        t0 = update_param(t0, new_t0, t0_index)
    elif t0_method == "Particle":
        t0 = updatate_particle_param(t0,new_t0,f_soil,f_soil_des)
    else:
        t0 = update_class_param(t0,new_t0,f_soil)
    if srm_method == "Grid":
        srm = update_param(srm, new_srm, srm_index)
    else:
        srm = update_class_param(srm, new_srm, f_lu)
    write_alpha_m(basin_id, alpha, m, f_alpha_m)
    write_sdbar(basin_id, sdbar, f_Sdbar)
    write_dl_dt(dl, dt, f_dl_dt)
    AsciiIO.write(f_n0, n0_headers, n0)
    AsciiIO.write(f_T0, t0_headers, t0)
    AsciiIO.write(f_Srmax, srm_headers, srm)


def read_soil_description(f_soil_des):
    """

    :param f_soil_des: .spr file in the input folder.
    :return: the composition of different types of soil
    """
    soil_des_matrix = np.genfromtxt(f_soil_des)[1:]
    soil_type = soil_des_matrix[:,0].astype("int16")
    description = soil_des_matrix[:,1:]
    soil_des = {}
    for i in range(len(soil_type)):
        soil_des[soil_type[i]] = description[i,:]
    return soil_des


def read_sub_basin(f_sub_basin):
    """

    :param f_sub_basin: .bk file in the input folder.
    :return:
    """
    headers, sub_basin, no_data_value = AsciiIO.read(f_sub_basin)
    #_, sub_basin = pop_nan(sub_basin, no_data_value)
    sub_basin_id = np.unique(sub_basin).astype("int32")
    sub_basin_id = sub_basin_id.tolist()
    sub_basin_id.remove(no_data_value)
    sub_basin_index = []
    for i in sub_basin_id:
        index = np.argwhere(sub_basin == i)
        sub_basin_index.append(index)
    return sub_basin_id, sub_basin_index


def change_cnd_path(cnd_file,new_path):
    with open(cnd_file) as f:
        text = f.readlines()
    text[5] = new_path + "\n"
    with open(cnd_file, "w") as f:
        f.writelines(text)

"""
cnd = r"D:\BtopmcCalibratorMulti\process1\siduxi.cnd"
pro = "process"
import sys
import os
abs = os.path.abspath(sys.argv[0])
dir = os.path.split(abs)[0]
print(dir)
change_cnd_path(cnd,dir+r"\process1")
"""